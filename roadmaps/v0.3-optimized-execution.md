# Roadmap: Version 0.3 – Optimized Execution

## Feature Goals

- Intermediate representation (IR) suitable for peephole optimizations, dead code elimination, and constant folding.
- Profiling hooks and tracing infrastructure to capture hot paths and runtime statistics.
- Optional tracing JIT interface capable of translating hot traces into native code when a backend is available.
- Enhanced debugging tools including stepper support, stack inspection, and source location mapping.
- Performance benchmarks and regression harnesses to validate optimizer effectiveness.

## Implementation Plan

### Phase 1 – IR & Optimizer Foundations
- Refactor the evaluator to emit a structured IR that retains source span metadata.
- Implement core optimization passes: constant folding, beta-reduction for lambdas, dead code elimination, and tail-call normalization.
- Add IR validation utilities and unit tests covering transformation correctness.

### Phase 2 – Profiling & Tracing Infrastructure
- Instrument the runtime with lightweight counters for function invocation frequency and allocation hotspots.
- Build a tracing API capable of capturing linearized instruction streams for hot code regions.
- Persist profiling data in a canonical format that can be consumed by external tooling.

### Phase 3 – Adaptive Execution
- Design a trait-based interface for pluggable code generators (JIT backends or ahead-of-time compilers).
- Implement a simple interpreter-specialization tier that caches optimized traces and replaces baseline execution.
- Integrate the profiler with the optimizer to drive dynamic recompilation decisions.

### Phase 4 – Tooling & Quality Gates
- Extend the CLI with profiling capture and visualization commands.
- Establish benchmark suites representing language idioms (numerics, list processing, macro-intensive code).
- Automate performance regression checks in CI, gating releases on defined thresholds.

## Open Questions

- Which backend (e.g., Cranelift, Wasmtime) offers the best balance of portability and performance for optional JIT support?
- How should the runtime expose optimizer controls to user code without compromising determinism?
