# Roadmap: Version 0.2 – Snapshot Persistence

## Feature Goals

- Deterministic heap snapshotting that captures the entire runtime state, including environments, closures, and pending continuations.
- Canonical module manifests that describe exported symbols, dependency hashes, and build metadata.
- Bytecode packaging format capable of bundling modules, manifests, and snapshots into a portable artifact.
- Snapshot loader that validates hashes, rewrites symbol identities, and resumes execution from a snapshot entry point.
- CLI tooling to create, inspect, and apply snapshots as part of a reproducible build pipeline.

## Implementation Plan

### Phase 1 – Snapshot Semantics
- Extend the runtime value graph with stable handles that can be serialized without duplicating shared structure.
- Implement serializer/deserializer pairs aligned with §6 canonical encodings, covering values, environments, and continuations.
- Introduce integrity checks using BLAKE3 digests to guarantee snapshot identity.

### Progress

- Implemented a handle-based heap capture that walks all live VM structures and preserves shared references while forming snapshot records.
- Added canonical snapshot encoders/decoders that serialize stacks, frames, and captured values with a BLAKE3 checksum for tamper detection.
- Exercised the new snapshot path via unit tests that round-trip synthetic VM state and verify digest failures are detected.

### Phase 2 – Module Manifests & Packaging
- Define a manifest schema recording module exports, dependency hashes, and build configuration data.
- Add packaging utilities to combine bytecode, manifests, and snapshots into a single archive (e.g., tarball or custom container).
- Support manifest validation and dependency resolution when loading packaged artifacts.

### Phase 3 – Tooling & CLI Integration
- Expose `oflisp snapshot` subcommands for creating, validating, and restoring snapshots.
- Document workflows integrating snapshots into CI pipelines and offline module distribution.
- Provide integration tests that round-trip representative programs through snapshot creation and restore.

## Open Questions

- Should snapshot archives support compression, and if so, which deterministic algorithm fits best?
- How should version skew between snapshots and runtime binaries be detected and resolved?
